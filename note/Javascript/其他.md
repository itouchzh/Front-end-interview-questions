# 其他

## 1. 浏览器

### 1.1 浏览器的缓存原理

```js
缓存的原理是在首次请求后保存一份请求的响应副本，当再次请求时，如果缓存命中，则直接拦截返回，将之前请求的结果反馈给用户，从而避免重新向服务器请求资源。
浏览器缓存可以分为强制缓存和协商缓存
区别在于响应头的设置：

强制缓存一般以max-age开头
协商缓存采用Etag开头，
强制缓存即直接返回缓存的响应信息，而协商缓存通过向服务器请求看资源是否发生改变，如果改变，则重新进行请求，如果没有改变，则直接返回缓存的资源。

cache-control有哪些值？
no-cache: 表示必须先与服务器确认返回的资源是否被修改过，如果已被修改则需要重新获取新的资源，否则可以使用缓存。
no-store: 表示不允许缓存任何版本的资源，每次请求都必须重新获取资源。
max-age: 表示资源可以缓存的最长时间，单位是秒。例如 max-age=3600 表示资源可以缓存一小时。
s-maxage: 与 max-age 类似，但仅适用于共享缓存（例如 CDN），而不适用于浏览器缓存。
public: 表示资源可以被任何中间缓存（例如 CDN）缓存。
private: 表示资源只能被浏览器缓存，而不允许被共享缓存（例如 CDN）缓存。
must-revalidate: 表示缓存必须在使用之前验证其有效性。如果缓存过期或者失效，则必须从原始服务器重新获取资源。
proxy-revalidate: 与 must-revalidate 类似，但仅适用于共享缓存（例如 CDN），而不适用于浏览器缓存。
```



### 1.2 浏览器的工作原理

> 1. 首先通过DNS获得IP地址
> 2. 通过TCP三次连接建立握手， TLS协商被用于https请求
> 3. 解析返回内容
> 4. 构建DOM树和CSSOM树
> 5. 将DOM树和CSSOM树合并为Render树
> 6. 执行Javascript脚本
> 7. 回流与重绘
> 8. 关闭连接





## 2. 计算机网络



### 2.1 Http1.0 1.1 和2.0 的区别

```
http1.0 每次请求都建立一个tcp连接，请求完成后立刻断开，属于短连接。
缺点：连接无法复用，每次请求都得重新建立连接，启动速度慢。

http1.1 多个请求可以共用一个tcp连接。若connection：close为短连接，connection:keep-alive为长连接。增加了host header, cache等缓存机制。 节约带宽、http1.1 引入了Entity tag ,If-Unmodified-Since,If-Match,If-None-Match等可供选择的缓存头来控制缓存策略，新增了状态码，如410，表示服务器上的某个资源被永久删除

http2.0 采用二进制格式而不是文本，完全多路复用，使用报头压缩降低开销，服务器可以将响应主动推送到客户端的缓存中。


```



### 2.2 Https加密原理

```
```



### 2.3 Http缓存

强制缓存三种情况：

```
强制缓存和协商缓存
强制缓存三种情况：
1. 浏览器 -》 浏览器缓存（没有该请求的缓存结果）=》发起http请求
2. 浏览器 -》 浏览器缓存（请求结果已经失效）=》使用协商缓存发起http请求
3. 浏览器 -》 浏览器缓存（有请求结果）=>直接使用
控制强制缓存的字段分别是Expires和Cache-Control，Cache-Control的优先级较高
Cache-Control的主要取值：
public: 所有内容都将被缓存，且客户端和代理服务器都可缓存
private:所有内容只能被浏览器缓存（默认值）
max-age: 能够缓存的时间，单位为秒
no-cache：客户端可缓存，但是是否使用缓存则需要经过协商缓存来验证决定
no-store： 所有内容都不会被缓存

浏览器缓存存放在：memory cache 和disk cache（内存缓存和硬盘缓存) 读取顺序为memory-》disk 
memory cache 和disk cache:
memory cache 的特点是 读取速度快，内存缓存会将编译解析后的文件，直接存放到该进程的内存中，占据一定内存资源，方便下次读取；具有一定的时效性，当该进程关闭， 该进程的内存就会被清空。
disk cache :读取缓存需要进行io操作，读取复杂，速度比memory cache慢。

协商缓存情况：
1. 浏览器 =》 浏览器缓存（缓存失效）=》携带该资源缓存标识，进行请求=》304资源无更新=》浏览器=》浏览器缓存=》返回结果
2. 浏览器=》浏览器缓存（缓存失效）=》 携带该资源的缓存标识，进行请求=》资源更新，重新返回请求结果200=》浏览器=》浏览器缓存（将新结果和缓存标识存到浏览器缓存中）

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。
向服务器发送请求时会携带If-Modified-Since字段，如果该时间和服务器最后资源修改时间不一致，则返回新资源
Etag是服务器返回当前资源的唯一标识
If-None-Match会在请求时携带给服务器，如果资源一致则返回304，使用缓存内容。否则返回新内容200
```



### 2.4 TCP和UDP的区别

```
tcp协议是面向连接的，仅仅支持单播传输，进行点到点的传输，是面向字节流的，传输可靠。有拥塞控制。

```

|              | tcp                              | udp                                        |
| ------------ | -------------------------------- | ------------------------------------------ |
| 是否连接     | 面向连接                         | 无连接                                     |
| 是否可靠     | 可靠传输，使用流量控制和拥塞控制 | 不可靠传输                                 |
| 连接对象个数 | 一对一通信                       | 支持一对一，一对多，多对一和多对多交互通信 |
| 传输方式     | 面向字节流                       | 面向报文                                   |
| 首部开销     | 首部开销最小20字节，最大60字节   | 首部开销小，仅仅8字节                      |
| 适用场景     | 适用要求可靠的传输应用           | 适用实时通信                               |

### 2.5 OSI七层模型

1. TCP五层模型:物理层、数据链路层、网络层、传输层、应用层

物理层：

数据链路层

网络层

传输层: TCP和UDP

应用层: HTTP

1. OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

### 2.6 三次握手与四次挥手

```js
三次握手：
第一次，客户端向服务端发送请求，请求连接
第二次：服务端收到客户端发送的请求信息，回复给客户端可以建立连接
第三次：客户端向服务端发送确认信息，确定连接
四次挥手：
第一次：客户端向服务端请求断开连接
第二次：服务端收到后向客户端发回确认报文
第三次：服务端信息传输完毕后，向客户端发回连接释放报文
第四次：客户端收到连接释放报文后，发回确认报文

```

### 2.7 Post和get的区别

```js
1. get 是用于请求资源的，post是用来传输对象的
2. get的请求参数在路径中，post的放在请求体中
3. get请求只发送一次，而post请求需要发送两次，先发送请求头，再发送请求体
4. get请求一般会被缓存，而post不会
5. get请求参数会被完整保存在浏览器的浏览历史里面，而post不会
6. get请求可以直接刷新或者回退，而post请求会重新ti'jiao
```







## 3.WebSocket











 

