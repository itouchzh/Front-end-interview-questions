<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            // 原型和原型链
            //     每个函数都有prototype，称之为原型，也叫原型对象。每个对象都有__proto__属性，这个属性指向他自己的原型对象
            //     同时原型对象也是对象，所以也有__proto__属性，这样一层一层形成的链式结构称为原型链。
            // console.log(Object)
            // console.log(Object.__proto__) // ƒ () { [native code] }
            // console.log(Object.__proto__.prototype) // nudefined
            // console.log(Object.prototype.__proto__) // null
            // console.log(Object.prototype.constructor === Object); // true
            // console.log(Object.prototype) // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}

            // console.log(Function)
            // console.log(Function.__proto__) // ƒ () { [native code] }
            // console.log(Function.__proto__.prototype) //undefined
            // console.log(Function.prototype.__proto__) // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
            // console.log(Function.prototype) // ƒ () { [native code] }

            // console.log(Function.prototype.__proto__ === Object.prototype) // true
            // console.log(Function.prototype === Function.__proto__) // true

            // function Person(name) {
            //     this.name = name
            // }
            // const person = new Person('paul')
            // console.log(person.__proto__ === Person.prototype) // true
            // console.log(person.__proto__.__proto__.__proto__); // null 一直查找到顶端为null
            // console.log(Person.__proto__ == Function.prototype) // true
            // console.log(Person.prototype.__proto__ == Object.prototype) ; // true Person.prototype的原型为Object.prototype
            // console.log(Person.prototype.constructor == Person) // true 构造函数的 prototype.constructor 指向本身

            console.log(Object.prototype)
            console.log(Object.prototype.__proto__)
            console.dir(Object.constructor.prototype)
            console.dir(Object.constructor.__proto__ === Object.constructor.prototype) // true
            console.dir(Object.__proto__  === Object.constructor.prototype) // true
            console.log(Function.prototype)
            console.log(Function.prototype.__proto__)
            console.log(Function.__proto__)
            console.log(Function.__proto__.__proto__)

            function F() {}
            const f = new F()
            console.log(f.prototype)
            console.log(F.prototype)
            console.log(f.__proto__)
            console.log(f.__proto__ === F.prototype)
            console.log(F.constructor === F.prototype)
            console.log(F.prototype.constructor === F)
            console.log(F.__proto__)
            console.log(F.prototype.__proto__)
            console.log(F.prototype.__proto__.__proto__)

            // function User() {}
            // const user = new User()
            // User.prototype.show = function () {
            //     console.log(1)
            // }
            // // console.log(User.__proto__ === Function.prototype);
            // Object.prototype.getShow = function () {
            //     console.log('getshow')
            // }
            // User.getShow()
            // console.dir(User)
            // console.dir(user);
            // user.show()
            // user.getShow()
        </script>
    </body>
</html>
