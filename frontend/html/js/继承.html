<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            // // ES6 实现继承: 通过使用类来实现继承
            // class Parent {
            //     constructor(name) {
            //         this.name = name
            //     }
            // }
            // // 子类
            // class Son extends Parent {
            //     constructor() {
            //         super('paul')
            //     }
            // }
            // let son = new Son()
            // console.table(son.name, son instanceof Son, son instanceof Parent, son.hasOwnProperty('name')) // paul true true true

            // function School() {
            //     this.address = '陕西西安'
            // }
            // let school = new School()
            // console.log(school)
            // console.log(school.__proto__ === School.prototype) // true

            // // 寄生组合式继承
            // function Parent(){
            //     this.name = 'Parent'

            // }
            // Parent.prototype.sayName = function(){
            //     console.log("This is sayName()")
            // }
            // function Son(){
            //     Parent.call(this)
            // }
            // // 将Son的原型指向Parent
            // Son.prototype = Object.create(Parent.prototype)
            // // 确保Son的构造器指向本身
            // Son.prototype.constructor = Son
            // let son = new Son()
            // son.sayName()
            // console.log(son.name)

            //  1. 原型链继承
            //  2. 盗用构造函数继承
            //  3. 组合继承
            // 4. 原型式继承
            // 5. 寄生式继承
            // 6. 寄生组合式继承

            // function Parent() {
            //     console.log('Parent')
            // }

            // Parent.prototype.sayName = function () {
            //     console.log('This is sayName()')
            // }

            // const son = new Parent()
            // console.log(son.constructor)

            // 1. 原型链继承
            // function Parent() {
            //     console.log('Parent')
            // }
            // Parent.prototype.sayHello = function () {
            //     console.log('This is sayHello()')
            // }
            // function Child(){}
            // Child.prototype = new Parent()
            // const child = new Child()
            // child.sayHello()

            // 2. 借用构造函数继承
            // function Parent(name) {
            //     console.log(name);
            //     console.log('Parent')
            // }
            // Parent.prototype.sayHello = function () {
            //     console.log('This is sayHello()')
            // }
            // function Child(name) {
            //     Parent.call(this, name)
            // }
            // const child = new Child("paul")
            // child.sayHello()

            // // 3. 组合继承
            // function Parent(name) {
            //     console.log(name);
            //     console.log('Parent')
            // }
            // Parent.prototype.sayHello = function () {
            //     console.log('This is sayHello()')
            // }
            // function Child(name) {
            //     Parent.call(this, name)
            // }
            // Child.prototype = new Parent()
            // const child = new Child("paul")
            // child.sayHello()

            // 4. 原型式继承
            // function object(o){
            //     function Father(){}
            //     Father.prototype = o
            //     return new Father()
            // }
            // const obj = {
            //     name:'paul',
            //     sayHello(){
            //         console.log('This is sayHello()');
            //     }
            // }
            // const child = object(obj)
            // child.sayHello()
            // console.log(child.name);

            // 5寄生式继承
            // function object(o) {
            //     function Father() {}
            //     Father.prototype = o
            //     return new Father()
            // }
            // function createObj (obj){
            //     const clone = object(obj)
            //     clone.sayName = function(){
            //         console.log('This is sayName()')
            //     }
            //     return clone
            // }
            // const obj = {
            //     name:'paul',
            //     sayHello(){
            //         console.log('This is sayHello()');
            //     }
            // }
            // const child = createObj(obj)
            // child.sayHello()
            // child.sayName()

            // 6. 寄生组合式继承,所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。

            function Father(name) {
                this.name = name
                console.log(name)
            }
            Father.prototype.sayHello = function () {
                console.log('This is sayHello()')
            }

            function Child(name) {
                // 继承属性，使用构造函数
                Father.call(this, name)
            }
            /* 使用原型链继承方法 */
            Child.prototype = Object.create(Father.prototype, {
                constructor: {
                    value: Child,
                },
            })
            const child = new Child('paul')
            child.sayHello()
        </script>
    </body>
</html>
